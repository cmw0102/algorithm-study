# 11651_좌표-정렬하기2

# 문제 분석
# 좌표-정렬하기와 반대로 이번엔 y좌표를 기준으로 정렬하고 y 좌표값이 같으면 x좌표를 기준으로 한다.

# 해결 과정
# 첫 번째 - 리스트 생성해서 넣고 값 바꾸기를 활용하여 x, y좌표 자리 체인지 후 값 구하기

import sys
input = sys.stdin.readline
n = int(input())
n_list = []

for _ in range(n):
    [a, b] = map(int, input().split())
    temp = a
    a = b
    b = temp
    n_list.append([a, b])

n_list.sort()

for i in range(n):
    print(n_list[i][1], n_list[i][0])

# 결론
# 기존에 풀었던 방식에 서로의 값만 변경해주는 코드를 추가하였고
# print문에서 x와 y의 바뀐 순서를 정상적으로 변경하여 출력하였기에 문제를 푸는데 있어 어려움은 없었다.


# ++ 추가 공부
# 첫 번째. temp 사용 안하고 입력 받은 후 바로 자리 변경하기
n_list.append([a, b])
# 이부분을
n_list.append([b, a])
# 이렇게 자리를 변경해서 받으면 내가 짠 코드와 동일한 성능을 가지게 된다.


# 두 번째. 람다 함수를 사용하여 쉽게 정렬하기
n_list.sort(key=lambda x: (x[1], x[0]))
# 람다 함수는 lambda 매개변수: 표현식 이렇게 작성 된다.
# 따라서 만약 n_list가
n_list = [[4, 5], [5, 6], [2, 3], [4, 2]]
# 이렇게 구현되어 있으면
n_list.sort(key=lambda x: (x[1], x[0]))
# 사용시
[[4, 2], [2, 3], [4, 5], [5, 6]]
# 이렇게 정렬 되는 것이다.
# 즉, x는 n_list의 각 요소를 가리키며, 각 요소의 두 번째 값(x[1])을 기준으로 정렬하게 되는 것이다.


# 세 번째. 람다 함수를 사용할 때 key는 왜 사용하는가?
# key를 사용하는 이유는 단순한 숫자, 문자열이 아닌 리스트, 튜플과 같이 여러 값을 포함하는 복합적인 구조를 정렬하기 위해 사용한다.
# ex - 1
words = ['apple', 'banana', 'cherry', 'date']
words.sort(key=len)  # 문자열의 길이를 기준으로 정렬
print(words)  # ['date', 'apple', 'cherry', 'banana']
# 위 코드를 보면 문자열의 길이를 기준으로 정렬하기 위해 key값을 길이로 설정한 것을 알 수 있다.
# ex - 2
data = [(1, 3), (2, 1), (3, 2)]
data.sort(key=lambda x: x[1])  # 두 번째 요소를 기준으로 정렬
print(data)  # [(2, 1), (3, 2), (1, 3)]
# 위 코드를 보면 튜플의 두 번째 요소를 기준((1, 3)에서 3을 말함)으로 정렬한 것을 알 수 있다.a
# 이를 통해 이번 문제는 람다를 사용하여 첫 번째 정렬 기준을 두 번째 요소, 두 번째 정렬 기준을 첫 번째 요소로 설정하면 된다는 것알 수 있다.
